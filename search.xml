<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css  高度塌陷 清除浮动 行内元素块元素</title>
      <link href="2021/06/08/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%9D%97%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/08/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%9D%97%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h2><h3 id="什么是高度塌陷"><a href="#什么是高度塌陷" class="headerlink" title="什么是高度塌陷"></a>什么是高度塌陷</h3><p>1.父元素高度自适应，子元素float之后，造成父元素高度为0，称之为高度塌陷，他产生条件就是子元素浮动（子元素脱离文档流，也可以理解为子元素漂浮起来）</p><h3 id="讨论高度塌陷"><a href="#讨论高度塌陷" class="headerlink" title="讨论高度塌陷"></a>讨论高度塌陷</h3><p>由于父元素的高度塌陷，则父元素下的所有元素都会向上移动，这样会导致页面布局混乱。如果我们 给父元素设置一个和子元素一样的高度，从效果来看似乎避免了高度塌陷问题，但是如果我们给子元素的高度改变了，我们会发现这个问题并没有实质性的解决。父元素并不能自动适应子元素的高度，因此不建议使用这种方法。</p><p>更具w3c的标准。在页面中元素都一个隐含的属性叫BFC（块级格式化上下文），该属性可以设置打开或者关闭（默认关闭），<strong>当开启元素的bfc后，元素将会具有如下特征：</strong><br>1.父元素的垂直外边距不会和子元素重叠<br>2.开启bfc的元素不会被浮动元素覆盖<br>3.开启bfc的元素可以包含浮动的子元素<br><strong>如何开启元素的bfc</strong><br>1.设置元素浮动<br>2.设置元素绝对定位<br>3.设置display.元素为inline-block<br>4.将元素的overflow设置为一个非visible值</p><blockquote><p>overflow: visible , hidden , scroll , auto , inhert<br>visible 默认值。内容不会被修剪，会呈现在元素框之外。<br>hidden 内容会被修剪，并且其余内容是不可见的。<br>scroll 内容会修建，但是浏览器会显示滚动条以便查看其余的内容<br>auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容<br>inherit 规定应该从父元素继承overflow属性的值</p></blockquote><ul><li>推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式</li><li>bfc应用于 清除浮动 排版。<br>但是在ie6及以下的浏览器中并不支持bfc，所以使用这种方式不能兼容IE6在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和bfc类似，所在IE6浏览器可以通过开通hasLayout来解决问题开启方式很多，我们直接使用一种副作用最小的：<br>直接将元素的zoom设置为1即可<br>zoom表示放大的意思，后面跟着一个数值，写几就将元素放大几倍<br>zoom：1表示不放大元素，但是通过该样式可以开启hasLayout<br>zoom这个样式，只在IE中支持，其他浏览器都不支持<br><strong>可以直接在高度塌陷的父元素的最后，添加一个空白的div</strong><blockquote><p>div{<br> clear: both;<br>height: 0;<br>overflow: hidden;<br>}<br><strong>通过after伪类</strong><br>父元素:after{<br>  content: “”;<br> height: 0;<br>clear: both;<br>overflow: hidden;<br>display: block;<br>visibility: hidden;<br>}</p></blockquote><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><h3 id="什么是浮动，什么是脱离文档流"><a href="#什么是浮动，什么是脱离文档流" class="headerlink" title="什么是浮动，什么是脱离文档流"></a>什么是浮动，什么是脱离文档流</h3></li></ul><p>1.普通流定位，又称为文档流定位，是页面元素的默认定位方式<br>页面中的块级元素：按照从上到下的方式逐个排列<br>页面中的行内元素：按照从左到右的方式逐个排列<br>但是如何让多个块级元素在一行内显示？<br>这里就引出了浮动定位</p><h4 id="2-浮动定位float"><a href="#2-浮动定位float" class="headerlink" title="2.浮动定位float"></a>2.浮动定位float</h4><p>float属性 取值为left/right<br>脱离文档流</p><h4 id="3-相对定位relative"><a href="#3-相对定位relative" class="headerlink" title="3.相对定位relative"></a>3.相对定位relative</h4><p>元素会相对于它原来的位置偏移某个距离，改变元素位置后，元素依然会保留语法（设置为相对定位的元素框会偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。）</p><h4 id="4-绝对定位absolute"><a href="#4-绝对定位absolute" class="headerlink" title="4.绝对定位absolute"></a>4.绝对定位absolute</h4><ol><li>脱离文档流-不占据页面空间</li><li>通过偏移属性固定元素位置</li><li>相对于最近的以定位的祖先元素现实位置固定</li><li>如果没有已定位祖先元素，那么就相当于最初的包含块（body,html）去实现位置的固定<h4 id="5-固定定位fixed"><a href="#5-固定定位fixed" class="headerlink" title="5.固定定位fixed"></a>5.固定定位fixed</h4>将元素固定在页面的某个位置处，不会随着滚动条而发生位置滚动<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3></li><li>浮动定位元素会被排除在文档流之外-脱离文档流（不占据页面的空间），其余的元素要上前补位</li><li>浮动元素会停靠在父元素的左边或右边，或者停靠在其他已浮动元素的边缘上（元素只能在当前所在行浮动）</li><li>浮动元素依然位于父元素之内</li><li>浮动元素处理的问题-解决多个块元素在一行内现实的问题<br>注意</li><li>一行内，显示不下所有的已浮动元素时，最后一个将换行</li><li>元素一旦浮动起来之后，那么宽度将成自适应（宽度有内容决定）</li><li>元素浮动起来之后，那么就将变成块级元素，尤其对行内元素，影响最大<br>块级元素：允许修改尺寸<br>行内元素：不允许修改尺寸</li><li>文本，行内元素，行内块元素时采用环绕的方式来排列的方式来排列的，时不会被浮动元素压在地下的，会巧妙的避开浮动元素。<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2>一：给父元素定高<br>缺点：给父元素固定高度违背了高度自适应的原则，不够灵活，不推荐使用<br>二：给父元素添加属性 overflow: hidden;<br>如果子元素定了高，父元素没有定高，父元素可以继承子元素的高<br>如果父元素定了高直接切割子元素 overflow这个css属性很灵活可以了解一下<br>三：在子元素的末尾添加一个空的 div ，并设置下方样式<br>div{<br> clear: both;<br> height: 0;<br> overflow: hidden;<br>}<br> 优点：所有浏览器都支持，并且容器溢出不会被裁剪；<br> 缺点：在页面中添加无意义的div，容易造成代码冗余。<br>四：万能清除浮动法<br>在父元素中内容的最后添加一个伪元素来实现第三种方案的功能，具体设置样式如下：<br>父元素:after{<br> content: “”;<br> height: 0;<br> clear: both;<br> overflow: hidden;<br> display: block;<br> visibility: hidden;<br>}<br> 优点：不会造成代码冗余，剩余代码性能优化，推荐使用。<h2 id="行内元素-块元素"><a href="#行内元素-块元素" class="headerlink" title="行内元素 块元素"></a>行内元素 块元素</h2>行内元素<br>常见的行内元素（a、i、span、img、input、label）<br>与其他行内元素并排<br>不能设置宽高，默认的宽度就是文字的宽度<br>块级元素：<br>霸占一行，不能与其他任何元素并列。<br>能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%。<br><img src="/images/%E5%9D%97%E5%85%83%E7%B4%A0%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0/1.png" alt="标签的区分"><br>块级元素可以设置margin,padding属性<br>行内元素的水平方向的padding-left和padding-right都会产生边距效果，但是竖直方向上的padding-top和padding-bottom都不会产生边距效果</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>v-model数据双向绑定的原理</title>
      <link href="2021/06/08/v-model%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>2021/06/08/v-model%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>vue数据初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var vm=new Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        obj:&#123;</span><br><span class="line">            a:1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created:function()&#123;</span><br><span class="line">        console.log(this.obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：<img src="/images/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/1.png"></p><p>我们可以看到属性a有两个对应的get和set方法，为什么会多出两个方法呢？因为vue是通过object.defineProperty()来实现数据劫持的。</p><p>object.defineProperty()是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先研究下它对应的两个描述属性get和set，object.defineProperty()方法会直接在一个对象上定义一个新属性，并返回此对象</p><p>在平常，我们很容易就可以打印一个对象的属性数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var Book=&#123;</span><br><span class="line">    name:&#x27;vue权威指南&#x27;</span><br><span class="line">&#125;；</span><br><span class="line">console.log(Book.name); //vue权威指南</span><br></pre></td></tr></table></figure><p>如果想要在执行console.log(book.name)的同时，直接给书名加个书名号，那要怎么处理呢？或者说要通过什么监听对象book的属性值。这时候Object.defindeProperty()就派上用场了，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Book=&#123;&#125;</span><br><span class="line">var name=&#x27;&#x27;;</span><br><span class="line">object.defineProperty(Book,&quot;name&quot;,&#123;</span><br><span class="line">    set:function(value)&#123;</span><br><span class="line">        name=value;</span><br><span class="line">        console.log(&#x27;你取一个书名叫做&#x27;+value)</span><br><span class="line">    &#125;，</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        return&#x27;《&#x27;+name+&#x27;》&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">Book.name=&#x27;vue权威指南&#x27;；// 你取一个书名叫做vue权威指南</span><br><span class="line">console.log(Book.name);//《vue权威指南》</span><br></pre></td></tr></table></figure><p>我们通过object.defineProperty()设置了对象Book的name 属性，对其get和set进行重写操作，顾名思义，get就是在读取name属性这个值触发的函数，set就是在设置name属性这个值触发的函数，所以当执行Book.name=’vue权威指南’这个语句时，控制台打印出‘你取了一个书名叫做vue权威指南’，紧接着，当读取这个属性时，就会输出“《vue权威指南》”，因为我们在get函数里面对该值做了加工了。如果这个时候我们执行下面的语句，控制台会输出什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Book)</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="/images/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/2.png"></p><p>乍一看，是不是跟我们在上面打印vue}数据长得有点类似，说明确实是通过这种方法来进行数据劫持的。接下来我们通过其原理来实现一个简单版的mvvm双向绑定代码<br><strong>思路分析</strong></p><p>实现mvvm主要包含两个方面，数据变化更新视图，视图变化更新数据：</p><p><img src="/images/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/3.png"></p><p>关键点在于data如何更新view ，因为view更新data 其实可以通过事件监听即可，比如input标签监听“input”事件就可以实现了。所以我们着重来分析下，当数据改变，如何更行视图的。</p><p>数据更行视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的是都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty()对象设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了。</p><p><img src="/images/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/4.png"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性上变化了，就需要告诉订阅者watcher看是否需要更新。因为订阅者是很多个。所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者watcher之间进行统一管理。接着，我们需要有一个指令解析器compile，对每一个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者watcher，并替换模板数据或者绑定相应的函数，此时当订阅者watcher接收到相应属性的变化，就会执行对应的更行函数，从而更新视图。因此接下来我们执行以下3个步骤，实现数据双向绑定：</p><p>1.实现一个监听器observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。</p><p>2.实现一个订阅者watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图</p><p>3.实现一个解析器compile,可以扫描和解析每一个节点的相关指令，并根据初始化相应的订阅器。</p><p>流程图如下：</p><p><img src="/images/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/5.png"></p><p><strong>1.实现一个Observer</strong></p><p>observer 是一个数据监听器，其实现核心方法就是前文所说的Object.defineProperty()。如果要对所有属性都进行监听的话。那么可以通过递归方法遍历所有属性值，并对其进行object.defineProperty()处理。如下代码，实现了一个observer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(data,key,val)&#123;</span><br><span class="line">    observe(val);//递归遍历所有子属性</span><br><span class="line">    object.defineProperty(data,key,&#123;</span><br><span class="line">        enumerable:true,</span><br><span class="line">        configurable:true,</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newVal)&#123;</span><br><span class="line">            val=newVal;</span><br><span class="line">            console.log(&#x27;属性&#x27;+key+&#x27;已经被监听了，现在值为：&quot;&#x27;+newVal.toString()+&#x27;&quot;&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function observer(data)&#123;</span><br><span class="line">    if(!data|| typeof data !==&#x27;object&#x27;)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    object.key(data).forEach(function(key))&#123;</span><br><span class="line">  defineReactive(data,key,data(key));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var library=&#123;</span><br><span class="line">    book1:&#123;</span><br><span class="line">        name:&#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    book2:&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">observe(library);</span><br><span class="line">library.book1.name=&#x27;vue权威指南&#x27;//属性name已经被监听了，现在值为：&#x27;vue权威指南&#x27;</span><br><span class="line">library.book2=&quot;没有此书籍&quot;//属性book2已经被监听了，现在值为：&#x27;没有此书籍&#x27;</span><br></pre></td></tr></table></figure><p>思路分析，需要创建一个可以容纳订阅者的消息订阅器Dep主要负责收集订阅者，然后再属性变化的时候执行对应订阅者的更新函数。所以显然订阅器需要有一个容器，这个容器就是list，将上面的observer稍微改造下，植入消息订阅器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(data,key,val)&#123;</span><br><span class="line">    observe(val);//递归遍历所有子属性</span><br><span class="line">    var dep=new Dep();</span><br><span class="line">    object.defineProperty(data,key&#123;</span><br><span class="line">        enumerable:true,</span><br><span class="line">        configurable:true,</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            if(是否需要添加订阅)&#123;</span><br><span class="line">                dep.addSub(watcher);//在这里添加一个订阅者</span><br><span class="line">            &#125;</span><br><span class="line">            return val;</span><br><span class="line">        &#125;，</span><br><span class="line">        set:function(newval)&#123;</span><br><span class="line">            if(val===newVal)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            val=newVal;</span><br><span class="line">            console.log(&#x27;属性&#x27;+key+&#x27;已经被监听了，现在值为：&quot;&#x27;+newVal.toString()+&#x27;&quot;&#x27;);</span><br><span class="line">            dep.notify();//如果数据变化，通知所有订阅者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)；</span><br><span class="line">&#125;</span><br><span class="line">function Dep()&#123;</span><br><span class="line">    this.subs=[];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype=&#123;</span><br><span class="line">    addSubs:function(sub)&#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;,</span><br><span class="line">    notify:function()&#123;</span><br><span class="line">        this.subs.forEach(function(sub)&#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码上看，我们将订阅Dep添加一个订阅者设计在getter里面，这里为了Watcher初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在setter函数里面，如果数据变化，就会去通知所有订阅者就会去执行对应的更行的函数。到此为止，一个比较完整Observer实现了，接下来我们开始设计Watcher。</p><h2 id="2-实现Watcher"><a href="#2-实现Watcher" class="headerlink" title="2.实现Watcher"></a><strong>2.实现Watcher</strong></h2><p>订阅者Watcher在初始化的时候需要将自己添加进订阅器Dep中。，那该如何添加呢？我们已经知道监听器Observer是在get函数执行了添加订阅者Wather的操作的，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作即可，那要如何触发get的函数，再简单不过了，只要获取对应的属性值就可以触发了，核心原因就是因为我们使用了object，defineProperty()进行数据监听。这里还有一个细节点需要处理，我们只要在订阅者Watcher初始化的时候才需要添加订阅者，所以需要做一个判断操作，因此可以在订阅器上做一下手脚：在Dep。target上缓存订阅者，添加成功后再将其去掉就可以了，订阅者Watcher的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Watcher(vm,exp,cb)&#123;</span><br><span class="line">    this.cb=cb</span><br><span class="line">    this.vm=vm</span><br><span class="line">    this.exp=exp</span><br><span class="line">    this.value=this.get()  //将自己添加到订阅器的操作</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype=&#123;</span><br><span class="line">    update:function()&#123;</span><br><span class="line">        this.run();</span><br><span class="line">    &#125;,</span><br><span class="line">    run:function()&#123;</span><br><span class="line">        var value=this.vm.data[this.exp]</span><br><span class="line">        var oldVal=this.value</span><br><span class="line">        if(value!==oldVal)&#123;</span><br><span class="line">            this.value=value</span><br><span class="line">            this.cb.call(this.vm,value,oldVal)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    get:function()&#123;</span><br><span class="line">        Dep.target=this//缓存自己</span><br><span class="line">        var value=this.vm.data[this.exp]//强制执行监听里的get函数</span><br><span class="line">        Dep.target=null//释放自己</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，我们需要对监听器Observer也做一个稍微调整，主要是对应Watcher类原型上的get函数。需要调整地方在于defineReactive函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive(data,key,val)&#123;</span><br><span class="line">    observer(val)//递归遍历所有子属性</span><br><span class="line">    var dep=new Dep()</span><br><span class="line">    object.defineProperty(data,key，&#123;</span><br><span class="line">        enumerable:true,</span><br><span class="line">        configurable:true,</span><br><span class="line">        get:function()&#123;</span><br><span class="line">            if(Dep.target)&#123;  //判断是否需要添加订阅者</span><br><span class="line">                dep.addSub(Dep.target)//在这里添加一个订阅者</span><br><span class="line">            &#125;</span><br><span class="line">            return val</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function(newVal)&#123;</span><br><span class="line">            if(val===newVal)&#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            val=newVal</span><br><span class="line">            console.log(&#x27;属性&#x27;+key+ &#x27;已经被监听了，现在值为：&quot;&#x27; + newVal.toString()+&#x27;&quot;&#x27;);</span><br><span class="line">            dep.notify()//如果数据变化，通知所有订阅者</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Dep.target=null</span><br></pre></td></tr></table></figure><p>到此为止，简单版的watcher设计完毕，这时候我们需要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了，因为这里还没有设计解析器Compile，所以对于模板数据我们都进行写死处理，假设模板上有一个节点，且id号为‘name’，并且双向绑定的变量也为‘name’,且通过两个大括号包起来（这里只是为了演示，暂时没有什么用处），模板如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>这时候我们需要将Observer和Watcher关联起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function SelfVue(data,el,exp)&#123;</span><br><span class="line">    this.data=data</span><br><span class="line">    observe(data)</span><br><span class="line">    el.innnerHTMl-this.data[exp]//初始化模板数据的值</span><br><span class="line">    new Watcher(this,exp,function(value)&#123;</span><br><span class="line">        el.innerHTML=value</span><br><span class="line">    &#125;)</span><br><span class="line">    return this </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在页面上new 以下SelfVue类，就可以实现数据的双向绑定了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1 id=&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/index.js&quot;&gt; &lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var ele=document.querySelector(&#x27;#name&#x27;)</span><br><span class="line">var selfVue=new Selfvue(&#123;</span><br><span class="line">    name:&#x27;hello world&#x27;</span><br><span class="line">&#125;,ele,&#x27;name&#x27;)</span><br><span class="line">window.setTimeout(function()&#123;</span><br><span class="line">    console.log(&#x27;name值改变了&#x27;)</span><br><span class="line">  selfVue.data.name=&#x27;canfoo&#x27;</span><br><span class="line">&#125;,2000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这时候打开页面，可以看到页面刚开始显示了是”hello world“，过了2s后就会变成”canfoo”了。到这里，总算大功告成一半了，但是还有一个细节问题,我们在赋值的时候是这样的形式‘ selfVue.data.name=’vanfoo’ ’而我们理想的形式是‘selfVue.name=’canfoo’ ’为了实现这样的形式，我们需要在new SelfVue的时候做一个代处理，让访问selfVue的属性代理为访问selfVue.data的属性，实现原理还是使用object.defineProperty()对属性值再包一层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function SalfVue(data,el,exp)&#123;</span><br><span class="line">    var self=this</span><br><span class="line">    this.data=data</span><br><span class="line">    object.keys(data).forEach(function(key)&#123;</span><br><span class="line">        self.proxyKeys(key)//绑定代理属性</span><br><span class="line">    &#125;)</span><br><span class="line">    observer(data)</span><br><span class="line">    el.innerHTML=this.data[exp]//初始化模板数据的值</span><br><span class="line">    new Watcher(this,exp,function(value)&#123;</span><br><span class="line">        el.innerHTML=value</span><br><span class="line">    &#125;)</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line">SelfVue.prototype=&#123;</span><br><span class="line">    proxyKeys:function(key)&#123;</span><br><span class="line">        var self=this</span><br><span class="line">        object.defineProperty(thjis,key,&#123;</span><br><span class="line">            enumerable:false,</span><br><span class="line">            configurable:true,</span><br><span class="line">            get:function proxyGetter()&#123;</span><br><span class="line">                return self.data(key)</span><br><span class="line">            &#125;,</span><br><span class="line">            set:function proxySetter(newVal)&#123;</span><br><span class="line">                self.data[key]=newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下我们就可以直接通过‘selfVue.name =’canfoo’ ’形式来进行改变模板数据了。</p><h2 id="3-实现Compile"><a href="#3-实现Compile" class="headerlink" title="3.实现Compile*"></a><em>3.实现Compile</em>*</h2><p>虽然上面已经实现了一个双向数据绑定的例子，但是整个过程都没有去解析dom节点，而是直接固定某个节点进行替换数据的，所以接下来需要实现一个解析器compile来做解析和绑定工作。解析器compile实现步骤：</p><p>1.解析模板命令，并替换模板数据，初始化视图</p><p>2.将模板指令对应的节点绑定对应的更新函数初始化相应的订阅器</p><p>为了解析模板，首先血药获取到dom元素然后对含有Dom元素上含指令的节点进行处理，因此这个环节需要对dom操作比较频繁，所有可以先建一个fragment片段，将需要解析的dom节点存入fragment片段里面进行处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function nodeToFragment(el)&#123;</span><br><span class="line">    var fragment=document.createDocumentFragment()</span><br><span class="line">    var child=el.fristchild</span><br><span class="line">    while(child)&#123;</span><br><span class="line">        fragment.appendChild(child)</span><br><span class="line">        child=el.fristchikd</span><br><span class="line">    &#125;</span><br><span class="line">    return fragment</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来需要遍历各个节点，对含有相关节点进行特殊处理，这里咱们先处理最简单的情况，只对带有‘’这种形式的指令进行处理，先简到难，后面考虑更多指令情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function compileElement (el) &#123;</span><br><span class="line">    var childNodes = el.childNodes;</span><br><span class="line">    var self = this;</span><br><span class="line">    [].slice.call(childNodes).forEach(function(node) &#123;</span><br><span class="line">        var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</span><br><span class="line">        var text = node.textContent;</span><br><span class="line"> </span><br><span class="line">       if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123;  // 判断是否是符合这种形式&#123;&#123;&#125;&#125;的指令</span><br><span class="line">            self.compileText(node, reg.exec(text)[1]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">            self.compileElement(node);  // 继续递归遍历子节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">function compileText (node, exp) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    var initText = this.vm[exp];</span><br><span class="line">    updateText(node, initText);  // 将初始化的数据初始化到视图中</span><br><span class="line">    new Watcher(this.vm, exp, function (value) &#123;  // 生成订阅器并绑定更新函数</span><br><span class="line">        self.updateText(node, value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line">function updateText (node, value) &#123;</span><br><span class="line">    node.textContent = typeof value == &#x27;undefined&#x27; ? &#x27;&#x27; : value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取到最外层节点后，调用compileElement函数，对所有子节点进行判断，如果节点是文本节点且匹配这种形式指令的节点就开始进行编译处理，编译处理首先需要初始化视图数据，对应上面所说的步骤1，接下去需要生成一个并绑定更新函数的订阅器，对应上面所说的步骤2。这样就完成指令的解析、初始化、编译三个过程，一个解析器Compile也就可以正常的工作了。为了将解析器Compile与监听器Observer和订阅者Watcher关联起来，我们需要再修改一下类SelfVue函数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function SelfVue (options) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    this.vm = this;</span><br><span class="line">    this.data = options;</span><br><span class="line"> </span><br><span class="line">    Object.keys(this.data).forEach(function(key) &#123;</span><br><span class="line">        self.proxyKeys(key);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    observe(this.data);</span><br><span class="line">    new Compile(options, this.vm);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改后，我们就不要像之前通过传入固定的元素值进行双向绑定了，可以随便命名各种变量进行双向绑定了： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/compile.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    var selfVue = new SelfVue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            title: &#x27;hello world&#x27;,</span><br><span class="line">            name: &#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    window.setTimeout(function () &#123;</span><br><span class="line">        selfVue.title = &#x27;你好&#x27;;</span><br><span class="line">    &#125;, 2000);</span><br><span class="line"> </span><br><span class="line">    window.setTimeout(function () &#123;</span><br><span class="line">        selfVue.name = &#x27;canfoo&#x27;;</span><br><span class="line">    &#125;, 2500);</span><br><span class="line"> </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如上代码，在页面上可观察到，刚开始titile和name分别被初始化为 ‘hello world’ 和空，2s后title被替换成 ‘你好’ 3s后name被替换成 ‘canfoo’ 了 </p><p>到这里，一个数据双向绑定功能已经基本完成了，接下去就是需要完善更多指令的解析编译，在哪里进行更多指令的处理呢？答案很明显，只要在上文说的compileElement函数加上对其他指令节点进行判断，然后遍历其所有属性，看是否有匹配的指令的属性，如果有的话，就对其进行解析编译。这里我们再添加一个v-model指令和事件指令的解析编译，对于这些节点我们使用函数compile进行解析处理： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function compile (node) &#123;</span><br><span class="line">    var nodeAttrs = node.attributes;</span><br><span class="line">    var self = this;</span><br><span class="line">    Array.prototype.forEach.call(nodeAttrs, function(attr) &#123;</span><br><span class="line">        var attrName = attr.name;</span><br><span class="line">        if (self.isDirective(attrName)) &#123;</span><br><span class="line">            var exp = attr.value;</span><br><span class="line">            var dir = attrName.substring(2);</span><br><span class="line">            if (self.isEventDirective(dir)) &#123;  // 事件指令</span><br><span class="line">                self.compileEvent(node, self.vm, exp, dir);</span><br><span class="line">            &#125; else &#123;  // v-model 指令</span><br><span class="line">                self.compileModel(node, self.vm, exp, dir);</span><br><span class="line">            &#125;</span><br><span class="line">            node.removeAttribute(attrName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们在稍微改造下类SelfVue，使它更像vue的用法： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function SelfVue (options) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    this.data = options.data;</span><br><span class="line">    this.methods = options.methods;</span><br><span class="line"> </span><br><span class="line">    Object.keys(this.data).forEach(function(key) &#123;</span><br><span class="line">        self.proxyKeys(key);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    observe(this.data);</span><br><span class="line">    new Compile(options.el, this);</span><br><span class="line">    options.mounted.call(this); // 所有事情处理好后执行mounted函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们可以来真正测试了，在页面上设置如下东西： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;input v-model=&quot;name&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        &lt;button v-on:click=&quot;clickMe&quot;&gt;click me!&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;js/observer.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/watcher.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/compile.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> </span><br><span class="line">     new SelfVue(&#123;</span><br><span class="line">        el: &#x27;#app&#x27;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            title: &#x27;hello world&#x27;,</span><br><span class="line">            name: &#x27;canfoo&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            clickMe: function () &#123;</span><br><span class="line">                this.title = &#x27;hello world&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            window.setTimeout(() =&gt; &#123;</span><br><span class="line">                this.title = &#x27;你好&#x27;;</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>是不是看起来跟vue的使用方法一样，哈，真正的大功告成！： </p><p><img src="/images/vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/6.gif"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>js继承</title>
      <link href="2021/06/07/js%E7%BB%A7%E6%89%BF/"/>
      <url>2021/06/07/js%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="js继承的6种方式"><a href="#js继承的6种方式" class="headerlink" title="js继承的6种方式"></a>js继承的6种方式</h2><p>想要继承，就必须要提供个父类（继承谁，提供继承的属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">function Person(name)&#123; //给构造涵数添加了参数</span><br><span class="line">   this.name=name;</span><br><span class="line">   this.sum=function()&#123;</span><br><span class="line">   alter(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age=10;//给构造函数添加了原型属性</span><br></pre></td></tr></table></figure><h3 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h3><p><strong>核心</strong>：</p><blockquote><p>将父类的实例作为子类的原型</p></blockquote><p><strong>特点</strong></p><ul><li>子类的实例也是父类的实例</li><li>可以方便的继承父类型的原型中的方法，但是属性的继承无意义</li></ul><p><strong>缺点：</strong></p><ul><li>只执行一次，无法给属性传值</li><li>属性的继承无意义、</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 父类型</span><br><span class="line">function Person(name,age,sex)&#123;</span><br><span class="line"> this.name=name</span><br><span class="line"> this.age=age</span><br><span class="line"> this.sex=sex</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi=function()&#123;</span><br><span class="line">console.log(&#x27;大家好，我是&#x27;+this.name)</span><br><span class="line">&#125;</span><br><span class="line">//子类型</span><br><span class="line">function Student()&#123;</span><br><span class="line">    this.score=100</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype=new Person()</span><br><span class="line">Student.prototype.constructor=Student</span><br><span class="line"></span><br><span class="line">var s1=new Student()</span><br><span class="line">s1.sayHi()//大家好，我是undefined</span><br><span class="line">console.log(s1.name)//undefined</span><br><span class="line">console.log(s1.age)//undefined</span><br><span class="line">console.log(s1.constructor)</span><br></pre></td></tr></table></figure><h3 id="二、借用构造函数继承"><a href="#二、借用构造函数继承" class="headerlink" title="二、借用构造函数继承"></a>二、借用构造函数继承</h3><p><strong>核心</strong>：</p><blockquote><p>在子类的内部调用父类，通过call改变父类中this的指向__等于是复制父类的实例属性给子类__</p></blockquote><p><strong>特点</strong></p><ul><li>创建子类实例时，可以像父类传递参数</li><li>可以实现多继承</li><li>可以方便的继承父类型的属性，但是无法继承原型中的方法</li></ul><p><strong>缺点：</strong></p><ul><li>实例并不是父类的实例，只是子类的实例</li><li>无法继承原型中的方法</li><li>无法实现函数复用，每一个子类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//构造器</span><br><span class="line">function Animation (name,age)&#123;</span><br><span class="line">    this.name=name</span><br><span class="line">    this.age=age</span><br><span class="line">&#125;</span><br><span class="line">Animation.prototype.eat=function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line">function Cat(name,age,sex,score)&#123;</span><br><span class="line">    Animation.call(this,name,age)//可以call多个父类对象</span><br><span class="line">    this.sex=sex</span><br><span class="line">    this.score=score</span><br><span class="line">&#125;</span><br><span class="line">var c1=new Cat(&#x27;tom&#x27;,19,&#x27;男&#x27;, 100)//可以传参</span><br><span class="line">//c1.eat()//报错   not a function</span><br><span class="line">console.log(c1 instanceof Animation)//false</span><br><span class="line">console.log(c1 instanceof Cat)//true</span><br></pre></td></tr></table></figure><h3 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//组合原型链和构造函数继承</span><br><span class="line"></span><br><span class="line">function SubType(name)&#123;</span><br><span class="line"></span><br><span class="line">    Person.call(this,name);//接用构造函数模式</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype=new Person();//原型链继承</span><br><span class="line"></span><br><span class="line">var sub=new SubType(&quot;gar&quot;);</span><br><span class="line"></span><br><span class="line">console.log(sub.name);//&quot;gar&quot;继承了构造函数属性</span><br><span class="line"></span><br><span class="line">console.log(sub.age);//10继承了父类原素的属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function content(obj)&#123;</span><br><span class="line"></span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    f.prototype=obj//继承了传入的参数</span><br><span class="line"></span><br><span class="line">    return.new F() //返回函数对象</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sup=new Person() //拿到父类的实例</span><br><span class="line"></span><br><span class="line">var sup1=content（sup）</span><br><span class="line"></span><br><span class="line">console.log(sup1.age)//10继承了父类函数的属性</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五、寄生式继承"><a href="#五、寄生式继承" class="headerlink" title="五、寄生式继承"></a>五、寄生式继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function content(obj)&#123;</span><br><span class="line"></span><br><span class="line">    function f()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    F.prototype=obj //继承了传入的参数</span><br><span class="line"></span><br><span class="line">    return new F（）//返回函数对象</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sup=new Person();</span><br><span class="line">//以上是原型式继承，给原型式继承再套个壳子传递参数</span><br><span class="line">function subobject(obj)&#123;</span><br><span class="line">    var sub =content(obj)</span><br><span class="line">    sub.name=&#x27;gar&#x27;</span><br><span class="line">    return sub</span><br><span class="line">&#125;</span><br><span class="line">var sup2=subobject(sup)</span><br><span class="line">//这个函数经过声明之后就成了可添加属性的对象</span><br><span class="line">console.log(typeof subobject)//function</span><br><span class="line">console.log(typeof sup2)//object</span><br><span class="line">console.log(sup2.name)//&#x27;gar&#x27;,返回了个sub对象，继承了sub的属性</span><br></pre></td></tr></table></figure><p><strong>核心</strong></p><blockquote><p>就是给原型式继承外套了个壳子。</p></blockquote><p><strong>特点</strong>：没有创建自定义类型，因为只是套了一个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</p><p><strong>缺点</strong>：没有到原型，无法复用。</p><h2 id="6-寄生组合式继承（常用）"><a href="#6-寄生组合式继承（常用）" class="headerlink" title="6.寄生组合式继承（常用）"></a>6.寄生组合式继承（常用）</h2><p><strong>核心</strong>：</p><blockquote><p>修复了组合继承的问题</p></blockquote><p><strong>寄生</strong>：在函数内返回对象然后调用</p><p><strong>组合</strong>：</p><p>1.函数的原型等于另一个实例。</p><p>2.在函数中用apply或者call或者call引用另一个构造函数，可传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//寄生</span><br><span class="line">function content（obj）&#123;</span><br><span class="line">    function F()&#123;&#125;</span><br><span class="line">    F.prototype=obj</span><br><span class="line">    return new F()</span><br><span class="line">&#125;</span><br><span class="line">//content就是F实例的另一种表示法</span><br><span class="line">var con=content(Person.prototype);</span><br><span class="line">//con实例（F实例）的原型继承了父类函数的原型</span><br><span class="line">//上述更像是原型继承了父类函数的原型</span><br><span class="line">//上述更像是原型链继承，只不过只继承了原型属性</span><br><span class="line"></span><br><span class="line">//组合</span><br><span class="line">function Sub()&#123;</span><br><span class="line">    Person.call(this)//这个继承了父类构造函数的属性</span><br><span class="line">&#125;//解决了组合式两次调用构造函数属性的缺点</span><br><span class="line">//重点</span><br><span class="line">Sub.prototype=con //继承了con实例</span><br><span class="line">con.constructor=Sub //一定要修复实例</span><br><span class="line">var sub1=new Sub()</span><br><span class="line">//Sub的实例就继承了构造函数属性，父类实例，con的函数属性</span><br><span class="line">console.log(sub1.age)//10</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原型和原型链</title>
      <link href="2021/06/06/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>2021/06/06/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>1.JavaScript是一门基于原型的语言，在软件设计模式中，有一种模式叫做原型模式，JavaScript正是利用这种模式而被创建出来<br>2.原型模式是用于创建重复的对象，同时又能保证性能，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。原型模式的目的是用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，也就是说利用已有的一个原型对象，可以快速地生成和原型对象一样的新对象实例<br>3.原型：一个可以被复制（或者叫克隆）的一个类，通过复制原型可以创建一个一模一样的新对象，也可以说原型就是一个模板，在设计语言中更准确的说是一个对象模板</p><ul><li>1)原型是定义了一些公用的属性和方法，利用原型创建出来的新对象实例会共享原型的所有属性和方法<br>实例代码</li></ul><blockquote><p>//创建原型<br>var Person=function(name){<br>  this.name=name<br>}<br>//原型的方法<br>Person.prototype.sayHello=function(){<br>   console.log(this.name+”，hello”)<br>}<br>//实例化创建新的原型对象，新的原型对象会共享原型的属性和方法<br>var person1=new Person(‘张三’)<br>var person2=new Person(‘李四’)</p><p>//张三,hello<br>person1.sayHello()<br>//李四，hello<br>person2.sayHello()</p><p>// 为新对象实例添加方法<br>// 通过原型创建的新对象实例是相互独立的<br>person1.getName = function(){<br>    console.log(this.name);<br> }</p><p> // zhangsan<br>person1.getName();<br>// Uncaught TypeError: person2.getName is not a function<br>person2.getName();<br> 这些是比较简单的</p></blockquote><h3 id="原型总结"><a href="#原型总结" class="headerlink" title="原型总结"></a>原型总结</h3><p> *所有引用类型都有一个_proto_(隐式原型)属性，属性值是一个普通对象（这个_proto_是两个杠）<br> *所有函数都有一个prototype(原型)属性，属性值是一个普通对象<br> *所有引用类型的_proto_属性指向它的构造函数的portotype<br> 函数的原型prototype：函数才有prototype，prototype是一个对象，指向了当前构造函数的引用地址<br> 函数原型对象_proto_:所有对象都有_proto_属性，当用构造函数实例化（new）一个对象时，会将新对象的_proto_属性指向构造函数的prototype</p><p><img src="/images/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" alt="原型对象和函数的原型的关系"></p><h3 id="初识Function"><a href="#初识Function" class="headerlink" title="初识Function"></a>初识Function</h3><p>如上面例子中的构造函数，JavaScript中函数也是对象，所以就可以通过_proto_查找到构造函数对象的原型。<br>Function对象作为一个函数，就会有prototype属性，该属性将对应”function () {}”对象。<br>Function对象作为一个对象，就有__proto__属性，该属性对应”Function.prototype”，也就是说，”Function.<em>proto</em> === Function.prototype”（后面补的）</p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p> *所有函数的_proto_都是指向function的prototype<br> *构造函数new出来的对象_proto_指向构造函数的prototype<br> *非构造函数实例化出的对象的prototype的_proto_指向object的protoype,Object的prototype指向null</p><p>所有的原型对象都会自动获得一个 constructor (构造函数)属性，这个属性（是一个指针）指向prototype属性所在的函数（person）</p><p>实例的构造函数属性（constructor）指向构造函数：person1.constructor == person</p><p>原型对象（person.prototype）是构造函数（person）的一个实例</p><h3 id="原型的分类"><a href="#原型的分类" class="headerlink" title="原型的分类"></a>原型的分类</h3><p>隐式原型（<em>proto_）:上面说的这个原型是javaScript中的内置属性[[prototype]],此属性继承自object对象，在脚本中没有标准的方式访问[[prototype]],但Firefox，safari和chrome在每个对象上都支持一个属性_proto</em>,隐式原型的作用是用来构成原型链，实现基于原型的继承</p><p>显示原型（prototype）：每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享</p><h3 id="原型的使用方式"><a href="#原型的使用方式" class="headerlink" title="原型的使用方式"></a>原型的使用方式</h3><p>通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象原型</p><p>在赋值原型prototype的时候使用function立即执行的表达式来赋值，可以封装私有的function，通过return的形式暴露出简单的使用名称以达到public/private的效果</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>1.原型链：原型链是原型对象创建过程的历史纪录，当访问一个对象的某个属性式，会先在这个对象本身属性上查找，如果没有找到，则会去它的_proto_隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会在构造函数的prototype的_proto_中查找，这样一层一层向上查找就会形成一个链式结构<br><img src="/images/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/2.png" alt="原型链的流程"><br>2.原型设计的问题：当查找一个对象的属性时，javascript会根据原型链向上遍历对象的原型，直到找到给定名称的属性为止，直到到达原型链的顶部仍然没有找到指定的属性，就会返回undefinde<br>(<strong>JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</strong>)<br>也可以理解为原型链继承时查找属性的过程是先查找自身属性不存在时，会在原型链中逐级查找<br>3.hasOwnProperty函数：可以用来检查对象自身是否还有某个属性，返回值是布尔值，当属性不存在时会向上查找对象原型链,hasOwnproperty是JavaScript中唯一一个处理属性但是不查找原型链的函数<br>4.getOwnPropertyNames函数：可以获取对象所有的自身属性，返回值是由对象自身属性名称组成的数组，同样不会向上查找对象原型链（大部分情况下Object.getOwnPropertyNames()与Object.keys(obj)的功能是一样的，我们一般也是用来获取一个JSON对象中所有属性，例如)</p><blockquote><p>const obj = {<br>   property1: 1,<br>  property2: 2,<br>};</p><p>console.log(Object.keys(obj));<br>console.log(Object.getOwnPropertyNames(obj));</p></blockquote><p>输出：</p><blockquote><p>Array [“property1”, “property2”]<br>Array [“property1”, “property2”]<br>）</p></blockquote><h3 id="原型链总结"><a href="#原型链总结" class="headerlink" title="原型链总结"></a>原型链总结</h3><p>一直往上层查找，直到到null还没有找到，则返回undefined<br>Object.prototype._ <em>proto</em> _ === null<br>所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象<br>5.<strong>JavaScript的原型是为了实现对象间的联系，解决构造函数无法数据共享而引入的一个属性，而原型链是一个实现对象间联系即继承的主要方法</strong></p><h2 id="原型于原型链面试题"><a href="#原型于原型链面试题" class="headerlink" title="原型于原型链面试题"></a>原型于原型链面试题</h2><h3 id="原型的理解"><a href="#原型的理解" class="headerlink" title="原型的理解"></a>原型的理解</h3><p>在javascript中，每定义一个对象（函数也是对象），对象中都会包含一些预定义的属性，其中每个函数都有prototype属性，这个属性指向函数的原型对象（_proto_这里是prototype内置属性），使其原型对象的好处是所有对象实例共享它所包含的属性和方法</p><h3 id="什么是原型链？原型链解决的是什么问题？"><a href="#什么是原型链？原型链解决的是什么问题？" class="headerlink" title="什么是原型链？原型链解决的是什么问题？"></a>什么是原型链？原型链解决的是什么问题？</h3><p>1.原型链解决的主要是继承问题<br>2.每个对象拥有一个原型对象，通过proto指针向其原型对象,并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null（object.prototype._proto_指向的是null）.这种关系被称为原型链（prototype chain）,<br>通过原型链一个对象可以拥有定义在其他对象中的属性和方法<br>3.构造函数parent，parent.prototype和实例p的关系如下（p.<em>proto</em>===parent.prototype）<br><img src="/images/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/3.png" alt="构造函数之间的关系"></p><h3 id="prototype和proto区别是什么？"><a href="#prototype和proto区别是什么？" class="headerlink" title="prototype和proto区别是什么？"></a>prototype和proto区别是什么？</h3><p>1.prototype是构造函数的属性<br>2._proto_是每个实例都有的属性，可以访问[[prototype]]属性<br>3.实例的_proto_与其构造函数的prototype指向的是同一个对象</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rem em px</title>
      <link href="2021/06/04/rem-em-px/"/>
      <url>2021/06/04/rem-em-px/</url>
      
        <content type="html"><![CDATA[<h2 id="PX"><a href="#PX" class="headerlink" title="PX"></a>PX</h2><p>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p><h3 id="PX特点"><a href="#PX特点" class="headerlink" title="PX特点"></a>PX特点</h3><ol><li>IE无法调整那些使用px作为单位的字体大小；</li><li>国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；</li><li>Firefox能够调整px和em，rem但是96%以上的中国网民使用IE浏览器(或内核)。</li></ol><h2 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h2><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p><h3 id="EM特点"><a href="#EM特点" class="headerlink" title="EM特点"></a>EM特点</h3><ol><li><p>em的值并不是固定的；</p></li><li><p>em会继承父级元素的字体大小。<br>注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p><p>  所以我们在写CSS的时候，需要注意两点：</p></li><li><p>body选择器中声明Font-size=62.5%；</p></li><li><p>将你的原来的px数值除以10，然后换上em作为单位；</p></li><li><p>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。<br>也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。</p></li></ol><h2 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h2><p>rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是一个例子：</p><p>p {font-size:14px; font-size:.875rem;}<br>注意： 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。</p><h2 id="px-与-rem-的选择？"><a href="#px-与-rem-的选择？" class="headerlink" title="px 与 rem 的选择？"></a>px 与 rem 的选择？</h2><p>对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。<br>对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。</p>]]></content>
      
      
      <categories>
          
          <category> HTML CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>响应式原理</title>
      <link href="2021/06/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
      <url>2021/06/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="面试被问到当场懵逼"><a href="#面试被问到当场懵逼" class="headerlink" title="面试被问到当场懵逼"></a>面试被问到当场懵逼</h3><p>我背的面试题里面没有这个方便的，我对面试官说这个里面说的是什么，他说“多媒体查询”，我还是懵逼，我以为是seo，后来查了一下</p><h3 id="响应式的由来"><a href="#响应式的由来" class="headerlink" title="响应式的由来"></a>响应式的由来</h3><p>响应式布局指的是同一页面在不同屏幕尺寸下有不同的布局.传统的开发方式是PC端开发一套,手机端再开发一套,而使用响应式布局只要开发一套就够，缺点就是CSS比较重.下面是博客网站对不同设备适配后的结果,分别是iPhone5/SE,iphone6/7/8,iphone 6/7/8 plus,ipad pro,dell台式宽屏(1440 X 900).<br>响应式设计与自适应设计的区别:响应式开发一套界面,通过检测视口分辨率,针对不同客户端在客户端做代码处理,来展现不同的布局和内容;自适应需要开发多套界面,通过检测视口分辨率,来判断当前访问的设备是pc端,平板,手机,从而请求服务层,返回不同的页面.</p><h3 id="CSS3中的Media-Query（媒介查询）是什么"><a href="#CSS3中的Media-Query（媒介查询）是什么" class="headerlink" title="CSS3中的Media Query（媒介查询）是什么"></a>CSS3中的Media Query（媒介查询）是什么</h3><p>通过不同的媒介类型和条件定义样式表规则。媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。媒介查询的大部分媒介特性都接受min和max用于表达”大于或等于”和”小于或等于”。如：width会有min-width和max-width媒介查询可以被用在CSS中的@media和@import规则上，也可以被用在HTML和XML中。通过这个标签属性，我们可以很方便的在不同的设备下实现丰富的界面，特别是移动设备，将会运用更加的广泛。<br><a href="https://blog.csdn.net/sinat_17775997/article/details/89087348">资料来自于</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML CSS </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
